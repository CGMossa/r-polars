---
title: "Some Notes and tips and examples - User Guide for R"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Polars - User Guide for R}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
options(rmarkdown.html_vignette.check_title = FALSE)
```



# Introduction

```{r}
library(polars)
```


## Transpose - An example where `<DataFrame>$transpose` is warranted for speed.

Imagine `mtcars` is really a several million row table and an operation like row-wise median
is needed. e.g. to compute MAD (Median average deviation). 
```{r}
# This expression computes column wise MAD, and fairly fast because polars mem lay-out is
# column-major.
MAD_all_col_expr = pl$all()$median()$sub(pl$all())$abs()$mean() |> print()
```


A median cannot be folded or reduced because it includes a sort of values.

# our "very big" DataFrame to compute row-wise MAD
```{r}
total_N = nrow(mtcars) # all rows have same type or at least a meaningful shared supertype
big_lf = pl$DataFrame(mtcars)$lazy()
chunk_size = 11 # rows or maybe 5000 rows per chunk for bigger data

# define chunks to not store an entire DataFrame of the HUGE maybe larger than memory LazyFrame.
slice_off = c(floor(seq(0, total_N, by = chunk_size)), total_N) |> unique()
slice_len = diff(slice_off)
slice_off = head(slice_off, -1)

# slice "very big" LazyFrame and transpose each chunk and then compute MAD on columns
# and lastly transpose back and concat (rbind) chunks.
MAD_df = lapply(seq_along(slice_off), \(i) {
  big_lf$slice(slice_off[i], slice_len[i])$
    collect()$
    transpose()$
    select(MAD_all_col_expr)$
    transpose(column_names = "MADs")
}) |>
  pl$concat()

big_lf_mad = big_lf$with_columns(MAD_df$get_column("MADs"))
big_lf_mad$fetch()

```



