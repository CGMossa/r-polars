% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/expr__expr.R
\name{Expr_apply}
\alias{Expr_apply}
\title{Expr_apply}
\usage{
Expr_apply(f, return_type = NULL)
}
\arguments{
\item{f}{r function mapping a series}

\item{return_type}{NULL or one of pl$dtypes, the output datatype, NULL is the same as input.}
}
\value{
Expr
}
\description{
Apply a custom/user-defined function (UDF) in a GroupBy or Projection context.
Depending on the context it has the following behavior:
-Selection
}
\details{
Copied from pypolars (revise)
Expects f to be of type Callable[\link{Any}, Any]. Applies a python function over each individual value in the column.

GroupBy

Expects f to be of type Callable[\link{Series}, Series]. Applies a python function over each group.

Implementing logic using a Python function is almost always \emph{significantly} slower and more memory intensive than implementing the same logic using the native expression API because:

The native expression engine runs in Rust; UDFs run in Python.

Use of Python UDFs forces the DataFrame to be materialized in memory.

Polars-native expressions can be parallelised (UDFs cannot).

Polars-native expressions can be logically optimised (UDFs cannot).

Wherever possible you should strongly prefer the native expression API to achieve the best performance. @description
Apply a custom/user-defined function (UDF) in a GroupBy or Projection context.

Depending on the context it has the following behavior:
Selection
Expects f to be of type Callable[\link{Any}, Any]. Applies a python function over each individual value in the column.
GroupBy

Expects f to be of type Callable[\link{Series}, Series]. Applies a python function over each group.

Implementing logic using a Python function is almost always \emph{significantly} slower and more memory intensive than implementing the same logic using the native expression API because:

The native expression engine runs in Rust; UDFs run in Python.
Use of Python UDFs forces the DataFrame to be materialized in memory.
Polars-native expressions can be parallelised (UDFs cannot).
Polars-native expressions can be logically optimised (UDFs cannot).
Wherever possible you should strongly prefer the native expression API to achieve the best performance.
}
\examples{
2+2
}
\keyword{Expr}
