% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/dataframe.R
\name{is_DataFrame_data_input}
\alias{is_DataFrame_data_input}
\title{#' R6 Class polar_rame
#'
#' It's real
polar_frame = R6::R6Class("polar_frame",
cloneable = TRUE,
private = list(
# pf lower level extendr object that interfaces with polars in rust.
pf = NULL,
groupby_input = NULL,}
\usage{
is_DataFrame_data_input(x)
}
\arguments{
\item{robj}{any R object to test}
}
\value{
bool
}
\description{
\if{html}{\out{<div class="sourceCode">}}\preformatted{deep_clone = function(name, value) \{
  #low level call rust side deep clone
  if (name == "pf") return(value$clone_extendr())
  value
\}
}\if{html}{\out{</div>}}
}
\details{
),
public = list(

\if{html}{\out{<div class="sourceCode">}}\preformatted{#' @description
#' print
#' @return self `polar_frame` object.
print = function() \{
  cat("polars DataFrame: ")
  private$pf$print()
  invisible(self)
\},

#' @description
#' Create a new polar_frame
#' @param data obj inheriting data.frame or list of vectors or Series
#' @return A new `polar_frame` object.
initialize = function(data) \{


  #polar frame
  if(isFALSE(data)) \{
    private$pf = FALSE #shallow
    return(self)
  \}

  #pass through init
  if(is_polar_frame(data)) \{
    private$pf = data$.__enclos_env__$private$pf #shallow
    return(self)
  \}

  #normal initialization from data
  if(is_polar_data_input(data)) \{
    private$pf =  minipolars:::new_pf(data)
    return(self)
  \}

  #lowerlevel through init
  if(identical(class(data),"DataFrame")) \{
    private$pf = data
    return(self)
  \}



  abort(paste("cannot initialize polar_frame with:",class(data)))
\},

#' @description
#'polar_frame to lazy polar_frame.

#' @return A new `lazy_frame` object with applied selection.
lazy = function() \{
  lazy_polar_frame$new(private$pf$lazy())
\},

#' @description
#' select on polar_Frame.
#' @param ... any Expr or any strings naming any_column (translated into Expr col(any_colum)))
#' @return A new `polar_frame` object with applied selection.
select = function(...) \{

  #construct on rust side array of expressions and strings (not yet interpreted as exprs)
  pra = construct_ProtoExprArray(...)

  #perform eager selection and unwrap result
  DataFrame = unwrap(private$pf$select(pra))

  #wrap in high-level polars_frame and return
  polar_frame$new(DataFrame)
\},

#' @description
#' select on polar_Frame.
#' @param rexpr any single Expr
#' @return A new `polar_frame` object with applied filter.
filter = function(rexpr) \{

  #perform eager filtering
  new_df = private$pf$lazy()$filter(rexpr)$collect()

  #and return new polar_frame
  polar_frame$new(new_df)
\},

#' @description
#' groupby on polar_Frame.
#' @param ... any Expr or string to groupby
#' @return A new `polar_frame` object with applied filter.
groupby = function(...) \{
  out = polar_frame$new(private$pf)
  out$.__enclos_env__$private$groupby_input =  construct_ProtoExprArray(...)

  out
\},

#' @description
#' groupby on polar_Frame.
#' @param ... any Expr to aggregate with
#' @return A new `polar_frame` object with applied aggregation.
agg = function(...) \{

  agg_input = construct_ProtoExprArray(...)

  new_df = private$pf$groupby_agg(
    private$groupby_input,
    agg_input
  )

  #and return new polar_frame
  polar_frame$new(new_df)
\},

#' @description
#' return polar_frame as data.frame.
#' @param ... any arg passed to as.data.frame, x and col.names are fixed
#' @return A new `data.frame` object .
as_data_frame = function(...) \{
  as.data.frame(
    x = private$pf$as_rlist_of_vectors(),
    col.names = private$pf$colnames(),
    ...
  )
\}
}\if{html}{\out{</div>}}

)
)

test if suitable to construct polar.frame
}
\examples{
is_polar_data_input(iris)
}
